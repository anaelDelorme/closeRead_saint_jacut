{
  "hash": "89fe9a18312e7b76218f2ce5f247f465",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Formation CloseRead\"\nauthor: Anaël Delorme\nformat:\n  html:\n    toc: true\n---\n\n```{=html}\n<style>\n  @import url(\"https://fonts.googleapis.com/css2?family=Cormorant+Garamond:ital,wght@0,300;0,400;0,500;0,600;0,700;1,300;1,400;1,500;1,600;1,700&family=Playfair+Display:ital,wght@0,400..900;1,400..900&display=swap\");\n\n  #quarto-document-content h1 {\n    font-family: \"Cormorant Garamond\", \"Times New Roman\", Times, serif;\n    font-weight: 500;\n    font-size: 2.3em;\n    line-height: 1.1;\n    margin-top: 0;\n  }\n\n  .objective, .process, .prerequisites {\n  background-color: #f4f4f9;\n  border-left: 6px solid #3498db;\n  padding: 20px;\n  margin: 20px 0;\n  border-radius: 5px;\n  box-shadow: 0 4px 6px rgba(0,0,0,0.1);\n}\n\nh2 {\n  color: #2c3e50;\n  border-bottom: 2px solid #3498db;\n  padding-bottom: 10px;\n}\n\n.class[data-key=\"easy\"] {\n  background-color: green;\n  border-radius: 5px;\n  padding: 3px;\n  display: inline-block;\n  color: white\n}\n\n.class[data-key=\"inter\"] {\n  background-color: orange;\n  border-radius: 5px;\n  padding: 3px;\n  display: inline-block;\n  color: white\n}\n\n.class[data-key=\"hard\"] {\n  background-color: red;\n  border-radius: 5px;\n  padding: 3px;\n  display: inline-block;\n  color: white\n}\n\npre code {\n    font-family: \"Fira Code\", monospace;\n    background-color: #f3f3f3;\n    color: #383a6b;\n    font-weight: bold; \n    padding: 5px 10px; /* Espacement interne */\n    border: solid 2px #383a6b;\n    border-radius: 8px; /* Bordure arrondie */\n    display: block; /* Utiliser block pour mieux gérer la largeur */\n    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2); /* Ombre légère */\n    overflow-x: auto; /* Activer le défilement horizontal si nécessaire */\n    white-space: pre-wrap; /* Préserver les espaces et permettre le wrapping */\n    max-width: 100%; /* Empêcher le dépassement de la largeur du conteneur parent */\n}\n\np code {\n    font-family: \"Fira Code\", monospace;\n    background-color: #f3f3f3;\n    color: #383a6b;\n    font-weight: bold; \n    padding: 5px 10px; /* Espacement interne */\n    border: solid 2px #383a6b;\n    border-radius: 8px; /* Bordure arrondie */\n    display: inline-block; /* Affichage inline-block */\n    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2); /* Ombre légère */\n}\n\n  \n</style>\n```\n\n\n\n\n\n\n\n\n\n\n\n\n## Formation Closeread {.objective}\n\n### Objectif \n\nCréer une première dataviz en datascrollytelling sur un thème qui vous tient à coeur.\n\n### Déroulement\n\nSelon votre niveau de connaissance en quarto/R/observable, vous pourrez vous arrêter en cours de formation. Mais vous aurez à toute étape une dataviz.\n\n1. **Storyboard** : Création du déroulé narratif de votre viz, avec création des textes et récupération des images/données utiles [facile]{.class key=\"easy\"}\n1. **Initialisation** : Création d'un document quarto et installation de closeread [facile]{.class key=\"easy\"}\n1. **Squellette de la viz** : Création de l'introduction/conclusion et des différentes parties de la dataviz [facile]{.class key=\"easy\"}\n1. **Scroll sur images** : Intégration d'images et de textes, avec le scroll qui fait apparaitre le texte et l'image correspondante [facile]{.class key=\"easy\"}\n1. **Scroll sur du texte** : Intégration de textes qui sera mis en évidence selon le scroll [facile]{.class key=\"easy\"}\n1. **Scroll sur un graphique en R** : Création de graphique qui évoluera selon le scroll [intermédiaire]{.class key=\"inter\"}\n1. **Modification du thème** : Changement de l'aspect de la dataviz en changeant le thème [intermédiaire]{.class key=\"inter\"}\n1. **Scroll sur des graphs ou cartes Javascript** : Création de cartes qui évoluent avec le scroll [avandé]{.class key=\"hard\"}\n1. **Déploiement sur Github Pages** : Diffusion sur Internet avec Github Pages [avandé]{.class key=\"hard\"}\n\n### Prérequis\n\n- Avoir accès à RStudio ou VSCode\n\n\n## Storyboard - réfléchir avant de plonger\n\nAvant de vous lancer dans la création de votre dataviz et de votre datascrollytelling dans Quarto, prenez le temps de réfléchir à l'organisation globale de votre projet. Un **storyboard** est un outil clé pour structurer votre récit et anticiper les étapes nécessaires à sa réalisation.\n\n- **Définissez un plan clair** : Identifiez les messages que vous voulez transmettre et dans quel ordre. Une narration bien pensée guidera vos lecteurs efficacement.    \n\n- **Préparez les éléments nécessaires** : Rassemblez les données, les textes, les images, et les illustrations qui enrichiront votre présentation.\n\n- **Pensez à l’interaction** : Repérez les points où vous voulez mettre l'accent, zoomer sur des éléments importants ou afficher des détails spécifiques.\n\n- **Visualisez vos transitions** : Comment passer d'une idée à l'autre ? Ces étapes doivent être fluides pour garder l’attention de votre audience.\n\nUn storyboard vous permettra de garder une vue d’ensemble tout en anticipant les défis techniques et narratifs. Cette préparation est essentielle pour maximiser l’impact de votre datascrollytelling !\n\n\n::: {.callout-tip title=\"Liens vers la documentation utile\"}\n\n- [Site Quarto](https://quarto.org/)\n\n- [Bases de markdown](https://quarto.org/docs/authoring/markdown-basics.html)\n\n- [Site closeread](https://closeread.dev/)\n\n:::\n\n## Initialisation [facile]{.class key=\"easy\"}\n\n**CloseRead** est une extension conçue pour fonctionner avec **Quarto.** Avant de commencer, assurez-vous que votre environnement de travail est prêt :\n\n1. Ouvrez RStudio : Lancez RStudio, l’environnement idéal pour travailler avec Quarto.\n\n1. Créez un projet dédié : Il est recommandé de créer un nouveau projet pour organiser vos fichiers. Cela facilitera la gestion des ressources et des dépendances.\n\n1. Créez un document Quarto : Générez un premier fichier .qmd (Quarto Markdown), qui servira de base à votre projet de datascrollytelling.\nPour ce faire, utilisez l’option Fichier > Nouveau fichier > Quarto Document dans RStudio.\n![](img/formation/new_quarto.png)\nPuis remplissez les différents paramètres (décocher l'éditeur visuel)\n![](img/formation/new_quarto_2.png)\n\n\n1. Installez l’extension CloseRead : À la racine de votre projet (là où se trouve votre fichier .qmd), installez l’extension CloseRead. Cela permettra d’ajouter les fonctionnalités nécessaires à votre projet. Cela se passe dans le terminal à droite de la console.\n![](img/formation/install_closeread.png)\n\n\n```\nquarto add qmd-lab/closeread\n```\n\n:::{.callout-warning}\nSi vous êtes sur Cerise, il n'est pas possible d'installer l'extension. Pour contourner cette difficulté, récupérer le fichier _extensions.zip que vous trouverez sur CERISE/04-Espace-Echanges/Ateliers/Closeread et Téléchargez-le à la racine de votre projet. Le fichier sera automatiquement décompressé et l'extension sera active.\n\n:::\n\nUne fois ces étapes terminées, vous serez prêt à explorer les possibilités offertes par CloseRead pour enrichir vos visualisations et votre storytelling.\n\n## Squelette de la viz [facile]{.class key=\"easy\"}\n\nVous pouvez commencer à créer un première squelette de dataviz : \n\n1. Paramétrage de l'entête YAML\n\nIl faut indiquer que le format est closeread-html\n\n```\n---\ntitle: Ma dataviz\nAuthor: Moi\nformat: closeread-html\n---\n```\n\n1. Ajoutez votre texte d'introduction\n\n2. Ajoutez vos différents titres\n\n:::{.callout-tip}\nUn titre de niveau 1 est précédé d'un `#`, un titre de niveau 2 de deux `##`, etc...\n:::\n\n3. Vérifiez que tout fonctionne\n\nEn cliquant sur le bouton `Rendu`, le quarto va générer une page web au format html.\n\n![](img/formation/rendu.png)\n\n:::{.callout-tip}\nEn lançant le `Rendu` il vous sera demandé de sauvegarder le fichier .qmd au préalable\n:::\n\n\nVous pouvez consulter le fichier d'exemple ici : [1-squelette](./example_formation/1-squelette.qmd){target=\"_blank\"}\n\n\n## Scroll sur images [facile]{.class key=\"easy\"}\n\n### Etape 1 - chargement des textes et des images\n\nPour comprendre le fonctionnement, très simple, de closeread, ajoutez des images et du texte dans une de vos parties.\n\n1. créez un répertoire `img` dans votre projet\n\n1. téléchargez vos photos\n\n1. dans votre .qmd ajoutez les photos et les textes en les alternant\n\n:::{.callout-tip}\nUne photo s'ajoute très simplement avec le code `![](./img/ma_photo.png)`\n:::\n\nVous pouvez tester un `rendu` pour vérifier que les images et le texte s'affichent correctement.\n\n### Etape 2 - ajout d'une section closeread\n\nVous pouvez passer à l'animation de votre page avec closeread. Le principe est de faire défiler les textes au dessus des images, avec les images qui vont changer selon le niveau de scroll.\n\nVous devez indiquer à votre document quarto que vous souhaitez ajouter une section closeread. Englobez votre texte et vos images par la balise ouvrante de section CloseRead `::::{.cr-section}` et la balise fermante `::::`.\n\nVoici mon code : \n```\n# Les grandes énigmes des données invisibles\n\n::::{.cr-section}\n\n![](./img/img1.webp)\n\n**L'énigme flottante des données invisibles**    \nLes chiffres chuchotent leurs secrets aux angles invisibles d'une géométrie oubliée. Saurons-nous un jour entendre leurs vérités non-numériques ? \n\n![](./img/img2.webp)\n\n**Le labyrinthe des connexions furtives**    \nChaque pixel est une porte, mais laquelle mène au sommet du triangle imaginaire ? Une énigme pour les esprits quantiques. \n\n![](./img/img3.webp)\n\n**L'éclipse des données perdues**     \nQuand les graphiques se camouflent dans les ombres des spectres, seule une poignée de courbes revient. Les autres ? Elles errent entre deux dimensions. \n\n::::\n\n```\n\nVous pouvez tester un `rendu` pour vérifier que les images et le texte s'affichent dans une section closeread. \nVous noterez que tout défile à gauche. En effet nous n'avons pas spécifié les éléments à mettre en défilement et les éléments à mettre en arrière plan.\n\n\n### Etape 3 - choix des éléments de défilement et d'arrière plan\n\nDans notre exemple, les textes sont en défilement et les images viennent en arrière plan les unes après les autres.\n\nL'élément qui ne bouge pas (un `sticky` en closeread) est encadré par une balise préfixé par `#cr-`. Par exemple, la balise ouvrante est `:::{#cr-monImage1}` et la fermante est `:::`.\n\nL'élement qui bouge (un trigger) est suivi de l'appel de ce sticky sous la forme `@cr-monImage1`.\n\nVoici le code final avec 3 images :\n\n```\n::::{.cr-section}           <!--- Début d'une section CloseRead --->\n\n:::{#cr-image1}             <!--- Un sticky (l'image de fond fixe) --->\n![](./img/img1.webp)\n:::                         <!--- Fin du sticky  --->\n**L'énigme flottante des données invisibles**    \nLes chiffres chuchotent leurs secrets aux angles invisibles d'une géométrie oubliée. Saurons-nous un jour entendre leurs vérités non-numériques ? @cr-image1   ## appel du texte qui vient défiler sur le sticky @cr-image1\n\n:::{#cr-image2}                <!--- Un autre sticky (l'image de fond change) --->\n![](./img/img2.webp)\n:::\n\n**Le labyrinthe des connexions furtives**    \nChaque pixel est une porte, mais laquelle mène au sommet du triangle imaginaire ? Une énigme pour les esprits quantiques. @cr-image2\n\n:::{#cr-image3}\n![](./img/img3.webp)\n:::\n\n**L'éclipse des données perdues**     \nQuand les graphiques se camouflent dans les ombres des spectres, seule une poignée de courbes revient. Les autres ? Elles errent entre deux dimensions. @cr-image3\n\n::::             <!--- Fin de ma section closeread --->\n\n```\nVous pouvez tester un `rendu` pour vérifier que le texte scrolle correctement et que l'image s'affiche bien.\n\n\nVous pouvez consulter le fichier d'exemple ici : [2-scroll_image](./example_formation/2-scroll_image.qmd){target=\"_blank\"}\n\n## Eléments de focus pour une image [facile]{.class key=\"easy\"}\n\nLes effets de focus permettent de diriger l'attention du lecteur sur certains aspects spécifiques de vos stickies. En reprenant l'exemple précédent, les effets de focus permettraient de diriger l'attention du lecteur sur une partie des images qui sont en stickies.\n\nPour utiliser un élément de focus, vous modifierez l'appel dans votre trigger. A la place de `Mon texte.... @cr-monSticky`, vous mettrez `Mon texte.... [@cr-monSticky]{type_focus=\"valeur_du_focus}\"`.\n\nEn closeRead, il existe 2 effets de focus sur une image : \n\n### Mise à l'échelle : **scale-by** \n\nVous pouvez ajuster la taille d’un sticky pour attirer l'attention ou donner un effet visuel.\n\n`[@cr-mycontent]{scale-by=\"1.5\"}`\n\nDans cet exemple, l'élément correspondant sera agrandi de 50 %.\n\n\n### Déplacement : **pan-to**\n\nPour centrer une partie précise d’un élément (souvent une image), vous pouvez utiliser l'attribut pan-to. Ce dernier accepte des unités relatives (%) ou absolues (pixels).\n\n`[@cr-mycontent]{pan-to=\"25%,-50%\"}` : l’élément sera déplacé de 25 % de sa largeur vers la droite et de 50 % de sa hauteur vers le haut.\n`[@cr-mycontent]{pan-to=\"-30px, 30px\"}` : l’élément sera déplacé de 30 px vers la gauche et de 30 px vers le bas.\n\n### Combinaison d'effets\n\nVous pouvez combinez les effets en les enchainant dans la déclaration.\n\n`[@cr-mycontent]{scale-by=\"1.5\" pan-to=\"25%,-50%\"}` : l’élément sera agrandi de 50% et déplacé de 25 % de sa largeur vers la droite et de 50 % de sa hauteur vers le haut.\n\n### Exemple\n\nVous pouvez adapter votre code précédent pour ajouter des effets de déplacements et de zoom.\n\n```\n::::{.cr-section}           <!--- Début d'une section CloseRead --->\n\n:::{#cr-image1}             <!--- Un sticky (l'image de fond fixe) --->\n![](./img/img1.webp)\n:::                         <!--- Fin du sticky  --->\n**L'énigme flottante des données invisibles**    \nLes chiffres chuchotent leurs secrets aux angles invisibles d'une géométrie oubliée. Saurons-nous un jour entendre leurs vérités non-numériques ? @cr-image1   ## appel du texte qui vient défiler sur le sticky @cr-image1\n\n:::{#cr-image2}                <!--- Un autre sticky (l'image de fond change) --->\n![](./img/img2.webp)\n:::\n\n**Le labyrinthe des connexions furtives**    \nChaque pixel est une porte, mais laquelle mène au sommet du triangle imaginaire ? Une énigme pour les esprits quantiques. @cr-image2\n\n:::{#cr-image3}\n![](./img/img3.webp)\n:::\n\n**L'éclipse des données perdues**     \nQuand les graphiques se camouflent dans les ombres des spectres, seule une poignée de courbes revient. Les autres ? Elles errent entre deux dimensions. @cr-image3\n\n::::             <!--- Fin de ma section closeread --->\n\n```\n\nVous pouvez consulter le fichier d'exemple ici : [3-scroll_image_with_focus](./example_formation/3-scroll_image_with_focus.qmd){target=\"_blank\"}\n\n\n## Scroll sur du texte [intermédiaire]{.class key=\"inter\"}\n\n:::{.callout-tip}\nLes effets sur les textes fonctionnent bien surtout sur des textes courts et en ligne comme les poèmes, ainsi que pour les lignes de code. \n:::\n\nPour l'instant nous avons vu le seul cas de figure où le sticky est une image. Il est possible d'avoir d'autres stickies comme du texte, ou du code.\n\nLe fonctionnement reste le même avec des triggers qui défilent sur du texte qui reste en fond de page. Des éléments de focus sont spécifiques aux textes\n\n### Zoom sur une ligne ou un élément spécifique : **zoom-to**\n\nUniquement si le sticky est du code ou une ligne, il est possible de zoomer directement sur une ligne ou un span identifié.\n\n`[@cr-mycontent]{zoom-to=\"3\"}` : zoom sur la ligne 3       \n`[@cr-mycontent]{zoom-to=\"cr-span1\"}` : zoom sur la ligne dont l'id est cr-span1     \n\n### Mise en surbrillance : **highlight**\n\nPour mettre en surbrillance du texte, vous pouvez utiliser le focus highlight :\n\n`[@cr-mycontent]{highlight=\"3-6\"}` : mise en surbrillance des lignes 3 à 6      \n`[@cr-mycontent]{highlight=\"cr-span1\"}` : zoom sur les lignes dont l'id est cr-span1\n\n\n### Cas particulier de code\n\nVous pouvez facilement zoomer ou mettre en surbrillance des lignes de code comme du texte normal ! C'est très puissant pour un support de formation en R ou Python.\n\nVous pouvez consulter le fichier d'exemple ici : [4-scroll-text-with-focus](./example_formation/4-scroll-text-with-focus.qmd){target=\"_blank\"}\n\n\n:::{.callout-tip}\nVous remarquerez dans la déclaration des textes la classe .scale-to-fill qui permet de mettre à l'échelle le sticky pour qu'elle remplisse la fenêtre de visualisation sans distorsion ni recadrage.\n:::\n\n## Scroll sur un graphique en R [intermédiaire]{.class key=\"inter\"}\n\nDans le datascrollytelling, l’utilisation de graphiques dynamiques constitue un puissant moyen de capter l’attention du lecteur et de transmettre des informations complexes de manière progressive. L’objectif est de synchroniser le texte défilant avec des visualisations interactives pour que les bonnes explications apparaissent au moment où les données pertinentes sont mises en avant. CloseRead facilite cette synchronisation en combinant des graphiques ggplot en \"stickies\" et des triggers en texte.\n\n::: {.callout-tip}\nSi vous n'avez pas envie de faire du ggplot, vous pouvez créer des graphiques dans un autre outil (datawrapper par exemple) et les exporter au format image. Ensuite il ne reste plus qu'à scroller ou zoomer comment pour les images.\n:::\n\n1. Créez le graphique complet en ggplot - écrivez les texte\n\nPour commencer vous devez créer votre graphique complet avec toutes les courbes. Pour que le scroll fasse apparaitre proprement les courbes il faut au préalable :\n\n- Pensez à définir les axes en fixant le min et le max : les axes ne bougeront pas quelque soient les données à afficher.      \n- Fixez la couleur des courbes pour qu'elles soient identiques quelque soit le scroll. Par exemple en faisant un `scale_color_manual(values = couleurs_especes)`.       \n- Intégrez la légende dans le graphique pour éviter que la taille de la légende fasse bouger la largeur du graphique.       \n\nRédigez par ailleurs les textes que vous souhaitez afficher.\n\nVoilà un exemple du code ggpglot :\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Chargement de ggplot2\nlibrary(ggplot2)\n\n# Création des données simulées\nset.seed(42)\ndata <- data.frame(\n  année = rep(2010:2019, 3),\n  population = c(\n    100 + cumsum(rnorm(10, mean = 5, sd = 3)),  # Plumifloron Azuré\n    40 + cumsum(rnorm(10, mean = -2, sd = 4)), # Taurillon Rubicond\n    80 + cumsum(rnorm(10, mean = 3, sd = 2))    # Luminéon Écarlate\n  ),\n  espèce = rep(c(\"Plumifloron Azuré\", \n                 \"Taurillon Rubicond\", \n                 \"Luminéon Écarlate\"), each = 10)\n)\n\n# On fixe les couleurs\ncouleurs_especes <- c(\n  \"Plumifloron Azuré\" = \"#1E90FF\",     \n  \"Taurillon Rubicond\" = \"#FF4500\",    \n  \"Luminéon Écarlate\" = \"#32CD32\"     \n)\n\n# Graphique avec un geom par courbe et axes fixes\nggplot(data, aes(x = année, y = population, color = espèce)) +\n  geom_line(data = subset(data, espèce == \"Plumifloron Azuré\")) +  \n  geom_line(data = subset(data, espèce == \"Taurillon Rubicond\")) +   \n  geom_line(data = subset(data, espèce == \"Luminéon Écarlate\")) +   \n  scale_x_continuous(limits = c(2010, 2019), breaks = 2010:2019) + \n  scale_y_continuous(limits = c(0, 175)) +    \n      scale_color_manual(values = couleurs_especes) +  \n  labs(\n    title = \"Évolution des populations animales (2010-2019)\",\n    x = \"Année\",\n    y = \"Population\",\n    color = \"Espèces\"\n  ) +\n  theme_minimal()+\n  theme(legend.position = c(.2, 0.9)) \n```\n:::\n\n\n\n\n\n\n2. Créez la section closeRead\n\nVous créez une section closeRead où vous mettez dedans : \n \n- des stickies correspondant à vos graphiques (donc des stickies qui englobent chacun un chunk R)\n- des textes pour les triggers\n\nDans notre exemple, nous avons 4 textes : un texte de présentation, puis un texte par espèce.\nNous avons donc également 4 stickies : un premier stocky qui comprend un chunk avec un graphique vide sans aucun geom_line, puis pour chacun des 3 autres stickies on ajoute à chaque fois un geom_line.\nIl ne reste plus qu'à faire coïncider les stickies et les triggers.\n\nL'exemple [5-scroll-graph-ggplot.qmd](./example_formation/5-scroll-graph-ggplot.qmd) vous montrera l'implémentation.\n\n::: {.callout-tip}\nNous avons choisi que le scroll permet d'afficher progressivement chacune des courbes. Vous pourriez aussi jouer sur la taille des courbes ou leurs couleurs. Le principe reste le même !\n:::\n\n\n::: {.callout-tip}\nVous pouvez jouer sur la taille du graphique affiché directement dans les options de quarto: fig-width et fig-height à définir dans les options du chunk.\n:::\n\n## Modification du thème [intermédiaire]{.class key=\"inter\"}\n\nUne datavisualisation efficace combine clarté des données et esthétique soignée. Pour cela, Quarto et CloseRead offrent des outils complémentaires : le premier permet une gestion globale du thème et la mise en page des éléments textuels, tandis que le second fournit des options pour personnaliser et enrichir la présentation dynamique.\n\n### Thèmes quarto\n\nPar défaut, quarto propose 25 thèmes de rendu [Voir HTML Theming dans la doc quarto](https://quarto.org/docs/output-formats/html-themes.html).\n\nDans l'entête yaml du document quarto, tentez simplement de paramétrer le thème. Par exemple, reprenez votre entente et mettez :\n\n```\n---\ntitle: \"Ma super dataviz\"\nauthor: \"Moi\"\nformat: \n  closeread-html:\n    theme: cyborg\n---\n```\n\nIl est possible de venir surcharger le thème en changeant la taille de la police, la couleur de fond, ect... Par exemple :\n\n```\n---\ntitle: \"Ma super dataviz\"\nauthor: \"Moi\"\nformat: \n  closeread-html:\n    theme: cyborg\n    backgroundcolor: darkslateblue\n    fontsize: 1.4em\n---\n```\n\nVous constaterez que seules les parties hors section closeRead sont impactées. C'est déjà un bon début.\n\n\n### Mise en page des éléments textuels\n\nQuarto permet le formatage classique de markdown : \n\n- Police : `*italics*, **bold**, ***bold italics***` \n\n- Titres : `# Header 1, ## Header 2, ### Header 3...`\n\n- Listes : `* unordered list\n    + sub-item 1\n    + sub-item 2\n        - sub-sub-item 1`\n        \n        \nQuarto permet également de créer des blocs avec des mises en forme spécifiques. Pour cela il faut créer une section et lui dire quel style appliqué selon les 5 possibilités : `note`, `tip`, `warning`, `caution`, and `important`.\nPar exemple : \n```\n:::{.callout-note}\nCeci est une note !\n:::\n\n:::{.callout-tip}\nEt là une astuce\n:::\n\n:::{.callout-warning title=\"Attention attention\"}\nMaintenant un bloc d'attention avec un titre\n:::\n\n```\n\n:::{.callout-warning}\nCes blocs ne semblent pas bien fonctionner dans le texte qui défile en Closeread.\n:::\n\n### Layouts CloseRead\n\nPar défaut le défilement se fait à gauche avec l'image/texte/graphique qui reste à droite. En closeread on dit que le layout est \"sidebar-left\". Pour le changer on peut soit le définir pour toute la page, soit pour une section en particulier.\n\nSi vous voulez le changer pour toute la page, vous l'indiquez dans le yaml en entête : \n\n```\n---\ntitle: \"Ma super dataviz\"\nauthor: \"Moi\"\nformat: \n  closeread-html:\n    theme: cyborg\n    backgroundcolor: darkslateblue\n    fontsize: 1.4em\n    cr-section:\n      layout: \"overlay-center\"\n---\n```\n\nPour le définir juste sur une section, vous devez l'indiquer à la création de la section : \n\n```\n:::{.cr-section layout=\"overlay-center\"}\n\n\n//// le contenu de la section ici...\n\n:::\n```\n\nLes options de layout sont \n\n- sidebar-left (par défaut)\n- sidebar-right\n- overlay-left\n- overlay-center\n- overlay-right\n\n### Thèmes et mise en page CloseRead\n\nLes aspects de rendu spécifiques de Closeread se paramètrent dans l'entête dans la clé cr-style. Par exemple : \n\n```\n---\ntitle: \"Ma super dataviz\"\nauthor: \"Moi\"\nformat: \n  closeread-html:\n    theme: cyborg\n    backgroundcolor: darkslateblue\n    fontsize: 1.4em\n    cr-section:\n      layout: \"overlay-center\"\n    cr-style:\n      narrative-background-color-sidebar: darkslateblue\n      narrative-text-color-sidebar: white\n      section-background-color: darkslateblue\n      narrative-background-color-overlay: violet\n      narrative-text-color-overlay: black\n---\n```\n\nDans cet exemple, j'ai passé tout le fond en violet aussi bien pour la partie de gauche où le texte scrolle que pour la partie centrale. \nPour le texte qui vient se mettre par dessus l'image, j'ai mis une couleur violette et un texte en noir.\nLes autres options sont disponibles sur le [site de documentation CloseRead](https://closeread.dev/guide/styling.html).\n\n### Mise en page CloseRead en CSS\n\nPour aller plus loin dans la mise en page, vous pouvez définir des éléments de feuilles de style dans votre document quarto.\nPar exemple, créez un chunk de type ```{=html} :\n\n```\n<!-- some quick style customisation: see https://closeread.dev/guide/styling -->\n<style>\n  .cr-section.overlay-left {\n    background-color: white;\n  }\n\n  .cr-section.overlay-left .narrative-col .narrative {\n    font-size: 1.15em;\n    background-color: #3a79aa;\n    color: #f1f1f1;\n    padding: 0.6em 0.8em;\n    border-radius: 1;\n    backdrop-filter: blur(10px);\n  }\n  \n  .cr-section.overlay-left .narrative-col .narrative a {\n    background-color: #3a79aa;\n    color: #f1f1f1;\n  }\n  \n</style>\n```\n\n\nVous pouvez voir un exemple ici : [6-scroll_image_with_theme.qmd](./example_formation/6-scroll_image_with_theme.qmd)\n\n## Scroll sur des graphs ou cartes Javascript [avancé]{.class key=\"hard\"}\n\nQuarto permet d'intéger des chunks Observable Javascript - OJS, permettant de faire du javascript directement en quarto. Pour rappel Javascript est  un langage de programmation principalement utilisé pour créer des interactions dynamiques et des fonctionnalités interactives sur les sites web. \nCloseread rentre en intéraction avec ces blocs ojs en les rendant dynamiques lors d'un scroll.\n\n### Base des blocs ojs\n\nNativement Quarto d'intégrer des chunks ojs de la même manière que des chunks r ou python. Pour obtenir le rendu d'un chunk ojs il faut lancer le rendu de la page complète (le run du seul chunk ne suffit pas).\n\nVoici un exemple très simple en utilisant un plot Observable [Voir Observable plot](https://observablehq.com/plot/) :\n\n```\n```{ojs}\n//| echo: false\n\ngistemp = FileAttachment(\"gistemp.csv\").csv({typed: true})\n\nPlot.plot({\n  y: {\n    grid: true,\n    tickFormat: \"+f\",\n    label: \"↑ Surface temperature anomaly (°C)\"\n  },\n  color: {\n    scheme: \"BuRd\",\n    legend: true\n  },\n  marks: [\n    Plot.ruleY([0]),\n    Plot.dot(gistemp, {x: \"Date\", y: \"Anomaly\", stroke: \"Anomaly\"})\n  ]\n})\n\n```\n```\n\n:::{callout-tip}\nPar défaut le code {ojs} est affiché. Pour l'enlever il faut ajouter le paramètre `//| echo: false` ou mettre dans l'entête yaml :\nexecute:     \n   echo: false\n:::\n\nEn savoir sur le [site de documentation Quarto](https://quarto.org/docs/interactive/ojs/)\n\n### Intéraction ojs et closeread\n\nQuand on regarde le graphique généré sur les anomalies de température depuis 1860, on pourrait avoir envie de parler de trois périodes et d'afficher les données selon ces trois périodes. Pour cela closeread propose une variable qui s'incrémente au fur à mesure du scroll. Il s'agit de crTriggerIndex. \n\nLe premier texte qui scrolle correspond à crTriggerIndex == 0, puis on passe à 1, puis 2, etc...\n\nSachant cela il est possible de mettre à jour le graphique pour prendre en compte ce crTriggerIndex pour réduire les données aux dates précisées. \n\nComme on l'a vu précédemment, il fut mettre dans une section closeread comme cela : \n\n```\n::::{.cr-section}\n\nLe premier texte à afficher sur le graphique vide @cr-plot\n\nLe second texte à afficher @cr-plot\n\nLe troisième @cr-plot\n\nLe dernier @cr-plot\n\n\n:::{#cr-plot}\n\n\n\n\n\n```{ojs}\n//| echo: false\n\ngistemp = FileAttachment(\"gistemp.csv\").csv({typed: true})\n\nfunction createPlot(data, startYear, endYear) {\n  return Plot.plot({\n    x: {\n      domain: [new Date(\"1880-01-01\"), new Date(\"2016-12-01\")], \n      label: \"Date →\"\n    },\n    y: {\n      domain: [-0.8, 1.4], \n      grid: true,\n      tickFormat: \"+f\",\n      label: \"↑ Surface temperature anomaly (°C)\"\n    },\n    color: {\n      scheme: \"BuRd\",\n      legend: true\n    },\n    marks: [\n      Plot.ruleY([0]),\n      Plot.dot(\n        data.filter(d => {\n          const year = new Date(d.Date).getFullYear();\n          return year >= startYear && year < endYear;\n        }), \n        {x: \"Date\", y: \"Anomaly\", stroke: \"Anomaly\"}\n      )\n    ],\n    width: Math.max(width, 900)\n  });\n}\n\nchart = {\n  if (crTriggerIndex == 0) {\n    return createPlot(gistemp, 0, 0);\n  }\n    else if (crTriggerIndex == 1) {\n    return createPlot(gistemp, 0, 1930);\n  } else if (crTriggerIndex == 2) {\n    return createPlot(gistemp, 0, 1980);\n  } else if (crTriggerIndex == 3) {\n    return createPlot(gistemp, 0, Infinity);\n  } else {\n    return createPlot(gistemp, 0, Infinity); \n  }\n}\n\n```\n\n\n\n\n\n:::\n\n\n::::\n\n```\n\n\n:::callout-tip\n\nPour plus de fluidité, la variable crTriggerProgress est \n:::\n\n\n### Cartes\n\n\n## Déploiement sur Github Pages [avancé]{.class key=\"hard\"}\n\n\n\n\n",
    "supporting": [
      "formation_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}